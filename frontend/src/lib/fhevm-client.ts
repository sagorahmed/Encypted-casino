// Temporarily relax FHEVM typings to avoid build-time type mismatch
// The current version of fhevmjs returns an InitOutput incompatible with prior FhevmInstance
// We treat the instance as `any` until full FHE integration is restored for Sepolia-only.
import { initFhevm } from "fhevmjs";
type FhevmInstance = any;
import { ethers } from "ethers";

let fhevmInstance: FhevmInstance | null = null;

const GAMEHOUSE_ADDRESS = process.env.NEXT_PUBLIC_GAMEHOUSE_ADDRESS || "";

const GAMEHOUSE_ABI = [
  "function deposit() public payable",
  "function withdraw(uint256 amount) public",
  "function playCoinFlip(bytes encryptedChoice, bytes choiceProof, uint256 betAmount, uint32 plaintextChoice) public returns (bool)",
  "function playRangePredictor(bytes encryptedChoice, bytes choiceProof, uint256 betAmount, uint32 plaintextChoice) public returns (bool)",
  "function depositHouseFunds() public payable",
  "function withdrawHouseFunds(uint256 amount) public",
  "function getEncryptedBalance(address player) public view returns (bytes32)",
  "function getTotalHouseBalance() public view returns (uint256)",
  "function getContractBalance() public view returns (uint256)",
  "function getHouseFunds() public view returns (uint256)",
  "function getGameHistoryLength() public view returns (uint256)",
  "function getGameResult(uint256 index) public view returns (tuple(address player, uint8 gameType, uint256 betAmount, bool won, uint256 timestamp, bytes32 encryptedOutcome))",
];

export async function initializeFHEVM(): Promise<FhevmInstance> {
  if (fhevmInstance) {
    return fhevmInstance;
  }

  const provider = new ethers.BrowserProvider(window.ethereum as any);
  
  // Note: chainId set to provider's chain for compatibility; adjust when using FHEVM network
  fhevmInstance = await initFhevm({
    chainId: (await provider.getNetwork()).chainId,
    provider: provider,
  });

  return fhevmInstance;
}

export function getFhevmInstance(): FhevmInstance | null {
  return fhevmInstance;
}

export async function getGameHouseContract(signer: ethers.Signer) {
  return new ethers.Contract(GAMEHOUSE_ADDRESS, GAMEHOUSE_ABI, signer);
}

export async function encryptCoinChoice(
  fhevm: FhevmInstance,
  choice: 0 | 1
): Promise<{ encrypted: string; proof: string }> {
  const encrypted = fhevm.encrypt32(choice);
  return {
    encrypted,
    proof: "", // Proof will be generated by fhevmjs
  };
}

export async function encryptRangeChoice(
  fhevm: FhevmInstance,
  choice: 0 | 1 // 0 = Below, 1 = Above
): Promise<{ encrypted: string; proof: string }> {
  const encrypted = fhevm.encrypt32(choice);
  return {
    encrypted,
    proof: "",
  };
}

export async function getUserBalance(
  contract: ethers.Contract,
  address: string
): Promise<string> {
  try {
    const encryptedBalance = await contract.getEncryptedBalance(address);
    // In production, this would be decrypted using FHE
    return encryptedBalance;
  } catch (error) {
    console.error("Error fetching balance:", error);
    return "0";
  }
}

export async function getHouseFunds(contract: ethers.Contract): Promise<string> {
  try {
    const funds = await contract.getHouseFunds();
    return ethers.formatEther(funds);
  } catch (error) {
    console.error("Error fetching house funds:", error);
    return "0";
  }
}

export async function getContractBalance(contract: ethers.Contract): Promise<string> {
  try {
    const balance = await contract.getContractBalance();
    return ethers.formatEther(balance);
  } catch (error) {
    console.error("Error fetching contract balance:", error);
    return "0";
  }
}
